<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dynamic Sequence Analyzer</title>
    <style>
        body { font-family: sans-serif; max-width: 600px; margin: 2rem auto; line-height: 1.5; padding: 0 1rem; color: #333; }
        .input-group { margin-bottom: 1.5rem; }
        label { display: block; font-weight: bold; margin-bottom: 0.25rem; }
        input[type="text"], input[type="number"], select { width: 100%; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
        .weights { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; background: #f9f9f9; padding: 1rem; border-radius: 8px; border: 1px solid #eee; }
        .error { color: #d93025; font-weight: bold; margin-top: 1rem; padding: 10px; background: #fce8e6; border-radius: 4px; display: none; }
        #results { margin-top: 2rem; border-top: 2px solid #eee; padding-top: 1rem; }
        .result-item { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #eee; }
        .final-score { font-size: 1.4rem; color: #1a73e8; font-weight: bold; margin-top: 1.5rem; text-align: center; background: #e8f0fe; padding: 10px; border-radius: 8px; }
        button { width: 100%; margin-top: 1rem; padding: 12px; background: #1a73e8; color: white; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; }
        button:hover { background: #1557b0; }
    </style>
</head>
<body>

    <h2>Sequence Data Analyzer</h2>

    <div class="input-group">
        <label>Enter Sequence (1-4 only, separated by spaces or commas):</label>
        <input type="text" id="dataInput" placeholder="e.g., 1, 3, 2, 4, 1, 2">
    </div>

    <div class="input-group">
        <label>Lookback Period (Recent Scores):</label>
        <select id="lookbackCount">
            <option value="2">Last 2 scores</option>
            <option value="3" selected>Last 3 scores</option>
            <option value="4">Last 4 scores</option>
        </select>
    </div>

    <div class="weights">
        <div>
            <label>Mode Weight (%)</label>
            <input type="number" id="wMode" value="25">
        </div>
        <div>
            <label>Overall Avg Weight (%)</label>
            <input type="number" id="wAvg" value="25">
        </div>
        <div>
            <label id="weightLabelLastN">Last 3 Avg Weight (%)</label>
            <input type="number" id="wLastN" value="25">
        </div>
        <div>
            <label>Trend Weight (%)</label>
            <input type="number" id="wTrend" value="25">
        </div>
    </div>

    <button onclick="analyze()">Calculate Results</button>

    <div id="errorMessage" class="error"></div>

    <div id="results" style="display:none;">
        <h3>Calculated Metrics</h3>
        <div class="result-item"><span>Mode:</span> <strong id="resMode">-</strong></div>
        <div class="result-item"><span>Overall Average:</span> <strong id="resAvg">-</strong></div>
        <div class="result-item"><span id="labelLastN">Last 3 Average:</span> <strong id="resLastN">-</strong></div>
        <div class="result-item"><span>Predicted Trend:</span> <strong id="resTrend">-</strong></div>
        <div class="final-score">Weighted Average: <span id="resFinal">-</span></div>
    </div>

<script>
// Keep track of the dropdown to update labels dynamically
document.getElementById('lookbackCount').addEventListener('change', function(e) {
    const val = e.target.value;
    document.getElementById('weightLabelLastN').innerText = `Last ${val} Avg Weight (%)`;
    document.getElementById('labelLastN').innerText = `Last ${val} Average:`;
});

function analyze() {
    const inputVal = document.getElementById('dataInput').value;
    const lookback = parseInt(document.getElementById('lookbackCount').value);
    const errDiv = document.getElementById('errorMessage');
    const resDiv = document.getElementById('results');
    
    // 1. Parse and Validate Input
    const rawItems = inputVal.split(/[ ,]+/).filter(i => i.length > 0);
    const nums = rawItems.map(Number);

    if (nums.length === 0 || nums.some(n => ![1, 2, 3, 4].includes(n))) {
        showError("Error: Please enter only the numbers 1, 2, 3, or 4.");
        return;
    }

    // 2. Validate Weights
    const wMode = parseFloat(document.getElementById('wMode').value) || 0;
    const wAvg = parseFloat(document.getElementById('wAvg').value) || 0;
    const wLastN = parseFloat(document.getElementById('wLastN').value) || 0;
    const wTrend = parseFloat(document.getElementById('wTrend').value) || 0;

    if (Math.abs((wMode + wAvg + wLastN + wTrend) - 100) > 0.01) {
        showError(`Warning: Weights add up to ${wMode + wAvg + wLastN + wTrend}%. They must add up to exactly 100%.`);
        return;
    }

    errDiv.style.display = 'none';
    resDiv.style.display = 'block';

    // 3. Calculations
    
    // Mode Logic
    const freq = {};
    nums.forEach(n => freq[n] = (freq[n] || 0) + 1);
    let mode = nums[0];
    let maxFreq = 0;
    for (const n in freq) {
        if (freq[n] > maxFreq) {
            maxFreq = freq[n];
            mode = Number(n);
        }
    }

    // Average Logic
    const avg = nums.reduce((a, b) => a + b, 0) / nums.length;

    // Dynamic Last N Average
    const lastNArr = nums.slice(-lookback);
    const lastNAvg = lastNArr.reduce((a, b) => a + b, 0) / lastNArr.length;

    // Trend Logic (Linear Regression)
    let trendPrediction = calculateTrend(nums);

    // 4. Final Weighted Average
    const finalScore = (
        (mode * (wMode / 100)) +
        (avg * (wAvg / 100)) +
        (lastNAvg * (wLastN / 100)) +
        (trendPrediction * (wTrend / 100))
    );

    // 5. UI Updates
    document.getElementById('resMode').innerText = mode.toFixed(2);
    document.getElementById('resAvg').innerText = avg.toFixed(2);
    document.getElementById('resLastN').innerText = lastNAvg.toFixed(2);
    document.getElementById('resTrend').innerText = trendPrediction.toFixed(2);
    document.getElementById('resFinal').innerText = finalScore.toFixed(2);
}

function calculateTrend(data) {
    const n = data.length;
    if (n < 2) return data[0]; 

    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
    for (let i = 0; i < n; i++) {
        sumX += i;
        sumY += data[i];
        sumXY += i * data[i];
        sumX2 += i * i;
    }

    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;

    // Predict the NEXT point in the sequence
    let prediction = (slope * n) + intercept;

    // Strict clamping [1, 4]
    return Math.min(4, Math.max(1, prediction));
}

function showError(msg) {
    const errDiv = document.getElementById('errorMessage');
    errDiv.innerText = msg;
    errDiv.style.display = 'block';
    document.getElementById('results').style.display = 'none';
}
</script>
</body>
</html>
