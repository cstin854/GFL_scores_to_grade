// --- UTILITY FUNCTIONS ---

/**
 * Parses the user input string into an array of numbers.
 * @param {string} input - The raw input string.
 * @returns {number[]} - An array of valid numbers.
 */
function parseInput(input) {
    return input
        .split(/[\s,]+/)
        .filter(s => s.trim() !== '')
        .map(Number)
        .filter(n => !isNaN(n));
}

/**
 * Calculates the slope (b) of the Least-Squares Regression Line (LSRL).
 */
function calculateSlope(x, y, meanX, meanY) {
    let numerator = 0;
    let denominator = 0;

    for (let i = 0; i < x.length; i++) {
        const dx = x[i] - meanX;
        const dy = y[i] - meanY;
        numerator += dx * dy;
        denominator += dx * dx;
    }

    return denominator === 0 ? 0 : numerator / denominator;
}

/**
 * Calculates the mode of an array of numbers.
 * - If unimodal, returns the single mode.
 * - If multimodal, returns the average of all modes.
 * - If no numbers repeat, returns 'N/A (No Repeat)'.
 * @param {number[]} arr - Array of numbers.
 * @returns {number|string} - The mode, average of modes, or 'N/A (No Repeat)'.
 */
function calculateMode(arr) {
    if (arr.length === 0) return 'N/A (Empty)';

    const counts = {};
    let maxCount = 0;

    // 1. Count frequencies and find max count
    arr.forEach(val => {
        // Use a string key for robust handling of floating point numbers
        const key = String(val);
        counts[key] = (counts[key] || 0) + 1;
        if (counts[key] > maxCount) {
            maxCount = counts[key];
        }
    });

    // 2. Find all values (modes) that match the max frequency
    const modes = [];
    for (const key in counts) {
        if (counts[key] === maxCount) {
            // Convert key back to number
            modes.push(Number(key));
        }
    }

    // 3. Handle results
    if (maxCount === 1) {
        // No number repeats (e.g., 1, 2, 3, 4)
        return 'N/A (No Repeat)';
    }

    // Unimodal (one mode) or Multimodal (multiple modes)
    if (modes.length === 1) {
        // Unimodal
        return modes[0];
    } else {
        // Multimodal: Calculate the average of the modes
        const sumOfModes = modes.reduce((acc, val) => acc + val, 0);
        return sumOfModes / modes.length;
    }
}

// --- MAIN PREDICTION FUNCTION ---

function predictNext() {
    const inputElement = document.getElementById('numberInput');
    const errorElement = document.getElementById('errorMessage');

    const trendEl = document.querySelector('#trendPrediction .result-value');
    const modeEl = document.querySelector('#modePrediction .result-value-secondary');
    const avgTwoEl = document.querySelector('#avgLastTwoPrediction .result-value-secondary');

    // Reset results
    [trendEl, modeEl, avgTwoEl].forEach(el => el.textContent = '--');
    errorElement.style.display = 'none';

    const data = parseInput(inputElement.value);

    if (data.length < 2) {
        errorElement.textContent = 'Please enter at least two valid numbers.';
        errorElement.style.display = 'block';
        return;
    }

    // --- 1. TREND PREDICTION (LSRL) ---
    const n = data.length;
    const x = Array.from({ length: n }, (_, i) => i);
    const y = data;

    const sumX = x.reduce((acc, val) => acc + val, 0);
    const sumY = y.reduce((acc, val) => acc + val, 0);
    const meanX = sumX / n;
    const meanY = sumY / n;

    const b = calculateSlope(x, y, meanX, meanY);
    const a = meanY - b * meanX;

    const nextX = n;
    const predictedY = a + b * nextX;
    trendEl.textContent = predictedY.toFixed(2);

    // --- 2. MODE PREDICTION (Updated) ---
    const modeResult = calculateMode(data);
    if (typeof modeResult === 'number') {
        modeEl.textContent = modeResult.toFixed(2);
    } else {
        modeEl.textContent = modeResult; // Will display 'N/A (No Repeat)'
    }

    // --- 3. AVERAGE OF LAST TWO ---
    const lastValue = data[n - 1];
    const secondLastValue = data[n - 2];
    const avgLastTwo = (lastValue + secondLastValue) / 2;
    avgTwoEl.textContent = avgLastTwo.toFixed(2);
}
</script>
